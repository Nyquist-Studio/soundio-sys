/* automatically generated by rust-bindgen 0.59.2 */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const SOUNDIO_MAX_CHANNELS: u32 = 24;
pub const SoundIoError_SoundIoErrorNone: SoundIoError = 0;
#[doc = " Out of memory."]
pub const SoundIoError_SoundIoErrorNoMem: SoundIoError = 1;
#[doc = " The backend does not appear to be active or running."]
pub const SoundIoError_SoundIoErrorInitAudioBackend: SoundIoError = 2;
#[doc = " A system resource other than memory was not available."]
pub const SoundIoError_SoundIoErrorSystemResources: SoundIoError = 3;
#[doc = " Attempted to open a device and failed."]
pub const SoundIoError_SoundIoErrorOpeningDevice: SoundIoError = 4;
#[doc = " Attempted to open a device and failed."]
pub const SoundIoError_SoundIoErrorNoSuchDevice: SoundIoError = 5;
#[doc = " The programmer did not comply with the API."]
pub const SoundIoError_SoundIoErrorInvalid: SoundIoError = 6;
#[doc = " libsoundio was compiled without support for that backend."]
pub const SoundIoError_SoundIoErrorBackendUnavailable: SoundIoError = 7;
#[doc = " An open stream had an error that can only be recovered from by"]
#[doc = " destroying the stream and creating it again."]
pub const SoundIoError_SoundIoErrorStreaming: SoundIoError = 8;
#[doc = " Attempted to use a device with parameters it cannot support."]
pub const SoundIoError_SoundIoErrorIncompatibleDevice: SoundIoError = 9;
#[doc = " When JACK returns `JackNoSuchClient`"]
pub const SoundIoError_SoundIoErrorNoSuchClient: SoundIoError = 10;
#[doc = " Attempted to use parameters that the backend cannot support."]
pub const SoundIoError_SoundIoErrorIncompatibleBackend: SoundIoError = 11;
#[doc = " Backend server shutdown or became inactive."]
pub const SoundIoError_SoundIoErrorBackendDisconnected: SoundIoError = 12;
#[doc = " Backend server shutdown or became inactive."]
pub const SoundIoError_SoundIoErrorInterrupted: SoundIoError = 13;
#[doc = " Buffer underrun occurred."]
pub const SoundIoError_SoundIoErrorUnderflow: SoundIoError = 14;
#[doc = " Unable to convert to or from UTF-8 to the native string format."]
pub const SoundIoError_SoundIoErrorEncodingString: SoundIoError = 15;
#[doc = " See also ::soundio_strerror"]
pub type SoundIoError = ::std::os::raw::c_uint;
pub const SoundIoChannelId_SoundIoChannelIdInvalid: SoundIoChannelId = 0;
#[doc = "< First of the more commonly supported ids."]
pub const SoundIoChannelId_SoundIoChannelIdFrontLeft: SoundIoChannelId = 1;
pub const SoundIoChannelId_SoundIoChannelIdFrontRight: SoundIoChannelId = 2;
pub const SoundIoChannelId_SoundIoChannelIdFrontCenter: SoundIoChannelId = 3;
pub const SoundIoChannelId_SoundIoChannelIdLfe: SoundIoChannelId = 4;
pub const SoundIoChannelId_SoundIoChannelIdBackLeft: SoundIoChannelId = 5;
pub const SoundIoChannelId_SoundIoChannelIdBackRight: SoundIoChannelId = 6;
pub const SoundIoChannelId_SoundIoChannelIdFrontLeftCenter: SoundIoChannelId = 7;
pub const SoundIoChannelId_SoundIoChannelIdFrontRightCenter: SoundIoChannelId = 8;
pub const SoundIoChannelId_SoundIoChannelIdBackCenter: SoundIoChannelId = 9;
pub const SoundIoChannelId_SoundIoChannelIdSideLeft: SoundIoChannelId = 10;
pub const SoundIoChannelId_SoundIoChannelIdSideRight: SoundIoChannelId = 11;
pub const SoundIoChannelId_SoundIoChannelIdTopCenter: SoundIoChannelId = 12;
pub const SoundIoChannelId_SoundIoChannelIdTopFrontLeft: SoundIoChannelId = 13;
pub const SoundIoChannelId_SoundIoChannelIdTopFrontCenter: SoundIoChannelId = 14;
pub const SoundIoChannelId_SoundIoChannelIdTopFrontRight: SoundIoChannelId = 15;
pub const SoundIoChannelId_SoundIoChannelIdTopBackLeft: SoundIoChannelId = 16;
pub const SoundIoChannelId_SoundIoChannelIdTopBackCenter: SoundIoChannelId = 17;
#[doc = "< Last of the more commonly supported ids."]
pub const SoundIoChannelId_SoundIoChannelIdTopBackRight: SoundIoChannelId = 18;
#[doc = "< First of the less commonly supported ids."]
pub const SoundIoChannelId_SoundIoChannelIdBackLeftCenter: SoundIoChannelId = 19;
pub const SoundIoChannelId_SoundIoChannelIdBackRightCenter: SoundIoChannelId = 20;
pub const SoundIoChannelId_SoundIoChannelIdFrontLeftWide: SoundIoChannelId = 21;
pub const SoundIoChannelId_SoundIoChannelIdFrontRightWide: SoundIoChannelId = 22;
pub const SoundIoChannelId_SoundIoChannelIdFrontLeftHigh: SoundIoChannelId = 23;
pub const SoundIoChannelId_SoundIoChannelIdFrontCenterHigh: SoundIoChannelId = 24;
pub const SoundIoChannelId_SoundIoChannelIdFrontRightHigh: SoundIoChannelId = 25;
pub const SoundIoChannelId_SoundIoChannelIdTopFrontLeftCenter: SoundIoChannelId = 26;
pub const SoundIoChannelId_SoundIoChannelIdTopFrontRightCenter: SoundIoChannelId = 27;
pub const SoundIoChannelId_SoundIoChannelIdTopSideLeft: SoundIoChannelId = 28;
pub const SoundIoChannelId_SoundIoChannelIdTopSideRight: SoundIoChannelId = 29;
pub const SoundIoChannelId_SoundIoChannelIdLeftLfe: SoundIoChannelId = 30;
pub const SoundIoChannelId_SoundIoChannelIdRightLfe: SoundIoChannelId = 31;
pub const SoundIoChannelId_SoundIoChannelIdLfe2: SoundIoChannelId = 32;
pub const SoundIoChannelId_SoundIoChannelIdBottomCenter: SoundIoChannelId = 33;
pub const SoundIoChannelId_SoundIoChannelIdBottomLeftCenter: SoundIoChannelId = 34;
pub const SoundIoChannelId_SoundIoChannelIdBottomRightCenter: SoundIoChannelId = 35;
#[doc = " Mid/side recording"]
pub const SoundIoChannelId_SoundIoChannelIdMsMid: SoundIoChannelId = 36;
#[doc = " Mid/side recording"]
pub const SoundIoChannelId_SoundIoChannelIdMsSide: SoundIoChannelId = 37;
#[doc = " first order ambisonic channels"]
pub const SoundIoChannelId_SoundIoChannelIdAmbisonicW: SoundIoChannelId = 38;
#[doc = " first order ambisonic channels"]
pub const SoundIoChannelId_SoundIoChannelIdAmbisonicX: SoundIoChannelId = 39;
#[doc = " first order ambisonic channels"]
pub const SoundIoChannelId_SoundIoChannelIdAmbisonicY: SoundIoChannelId = 40;
#[doc = " first order ambisonic channels"]
pub const SoundIoChannelId_SoundIoChannelIdAmbisonicZ: SoundIoChannelId = 41;
#[doc = " X-Y Recording"]
pub const SoundIoChannelId_SoundIoChannelIdXyX: SoundIoChannelId = 42;
#[doc = " X-Y Recording"]
pub const SoundIoChannelId_SoundIoChannelIdXyY: SoundIoChannelId = 43;
#[doc = "< First of the \"other\" channel ids"]
pub const SoundIoChannelId_SoundIoChannelIdHeadphonesLeft: SoundIoChannelId = 44;
pub const SoundIoChannelId_SoundIoChannelIdHeadphonesRight: SoundIoChannelId = 45;
pub const SoundIoChannelId_SoundIoChannelIdClickTrack: SoundIoChannelId = 46;
pub const SoundIoChannelId_SoundIoChannelIdForeignLanguage: SoundIoChannelId = 47;
pub const SoundIoChannelId_SoundIoChannelIdHearingImpaired: SoundIoChannelId = 48;
pub const SoundIoChannelId_SoundIoChannelIdNarration: SoundIoChannelId = 49;
pub const SoundIoChannelId_SoundIoChannelIdHaptic: SoundIoChannelId = 50;
#[doc = "< Last of the \"other\" channel ids"]
pub const SoundIoChannelId_SoundIoChannelIdDialogCentricMix: SoundIoChannelId = 51;
pub const SoundIoChannelId_SoundIoChannelIdAux: SoundIoChannelId = 52;
pub const SoundIoChannelId_SoundIoChannelIdAux0: SoundIoChannelId = 53;
pub const SoundIoChannelId_SoundIoChannelIdAux1: SoundIoChannelId = 54;
pub const SoundIoChannelId_SoundIoChannelIdAux2: SoundIoChannelId = 55;
pub const SoundIoChannelId_SoundIoChannelIdAux3: SoundIoChannelId = 56;
pub const SoundIoChannelId_SoundIoChannelIdAux4: SoundIoChannelId = 57;
pub const SoundIoChannelId_SoundIoChannelIdAux5: SoundIoChannelId = 58;
pub const SoundIoChannelId_SoundIoChannelIdAux6: SoundIoChannelId = 59;
pub const SoundIoChannelId_SoundIoChannelIdAux7: SoundIoChannelId = 60;
pub const SoundIoChannelId_SoundIoChannelIdAux8: SoundIoChannelId = 61;
pub const SoundIoChannelId_SoundIoChannelIdAux9: SoundIoChannelId = 62;
pub const SoundIoChannelId_SoundIoChannelIdAux10: SoundIoChannelId = 63;
pub const SoundIoChannelId_SoundIoChannelIdAux11: SoundIoChannelId = 64;
pub const SoundIoChannelId_SoundIoChannelIdAux12: SoundIoChannelId = 65;
pub const SoundIoChannelId_SoundIoChannelIdAux13: SoundIoChannelId = 66;
pub const SoundIoChannelId_SoundIoChannelIdAux14: SoundIoChannelId = 67;
pub const SoundIoChannelId_SoundIoChannelIdAux15: SoundIoChannelId = 68;
#[doc = " Specifies where a channel is physically located."]
pub type SoundIoChannelId = ::std::os::raw::c_uint;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutIdMono: SoundIoChannelLayoutId = 0;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutIdStereo: SoundIoChannelLayoutId = 1;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId2Point1: SoundIoChannelLayoutId = 2;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId3Point0: SoundIoChannelLayoutId = 3;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId3Point0Back: SoundIoChannelLayoutId = 4;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId3Point1: SoundIoChannelLayoutId = 5;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId4Point0: SoundIoChannelLayoutId = 6;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutIdQuad: SoundIoChannelLayoutId = 7;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutIdQuadSide: SoundIoChannelLayoutId = 8;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId4Point1: SoundIoChannelLayoutId = 9;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId5Point0Back: SoundIoChannelLayoutId = 10;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId5Point0Side: SoundIoChannelLayoutId = 11;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId5Point1: SoundIoChannelLayoutId = 12;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId5Point1Back: SoundIoChannelLayoutId = 13;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId6Point0Side: SoundIoChannelLayoutId = 14;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId6Point0Front: SoundIoChannelLayoutId = 15;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutIdHexagonal: SoundIoChannelLayoutId = 16;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId6Point1: SoundIoChannelLayoutId = 17;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId6Point1Back: SoundIoChannelLayoutId = 18;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId6Point1Front: SoundIoChannelLayoutId = 19;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId7Point0: SoundIoChannelLayoutId = 20;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId7Point0Front: SoundIoChannelLayoutId = 21;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId7Point1: SoundIoChannelLayoutId = 22;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId7Point1Wide: SoundIoChannelLayoutId = 23;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutId7Point1WideBack: SoundIoChannelLayoutId = 24;
pub const SoundIoChannelLayoutId_SoundIoChannelLayoutIdOctagonal: SoundIoChannelLayoutId = 25;
#[doc = " Built-in channel layouts for convenience."]
pub type SoundIoChannelLayoutId = ::std::os::raw::c_uint;
pub const SoundIoBackend_SoundIoBackendNone: SoundIoBackend = 0;
pub const SoundIoBackend_SoundIoBackendJack: SoundIoBackend = 1;
pub const SoundIoBackend_SoundIoBackendPulseAudio: SoundIoBackend = 2;
pub const SoundIoBackend_SoundIoBackendAlsa: SoundIoBackend = 3;
pub const SoundIoBackend_SoundIoBackendCoreAudio: SoundIoBackend = 4;
pub const SoundIoBackend_SoundIoBackendWasapi: SoundIoBackend = 5;
pub const SoundIoBackend_SoundIoBackendDummy: SoundIoBackend = 6;
pub type SoundIoBackend = ::std::os::raw::c_uint;
#[doc = "< capture / recording"]
pub const SoundIoDeviceAim_SoundIoDeviceAimInput: SoundIoDeviceAim = 0;
#[doc = "< playback"]
pub const SoundIoDeviceAim_SoundIoDeviceAimOutput: SoundIoDeviceAim = 1;
pub type SoundIoDeviceAim = ::std::os::raw::c_uint;
pub const SoundIoFormat_SoundIoFormatInvalid: SoundIoFormat = 0;
#[doc = "< Signed 8 bit"]
pub const SoundIoFormat_SoundIoFormatS8: SoundIoFormat = 1;
#[doc = "< Unsigned 8 bit"]
pub const SoundIoFormat_SoundIoFormatU8: SoundIoFormat = 2;
#[doc = "< Signed 16 bit Little Endian"]
pub const SoundIoFormat_SoundIoFormatS16LE: SoundIoFormat = 3;
#[doc = "< Signed 16 bit Big Endian"]
pub const SoundIoFormat_SoundIoFormatS16BE: SoundIoFormat = 4;
#[doc = "< Unsigned 16 bit Little Endian"]
pub const SoundIoFormat_SoundIoFormatU16LE: SoundIoFormat = 5;
#[doc = "< Unsigned 16 bit Big Endian"]
pub const SoundIoFormat_SoundIoFormatU16BE: SoundIoFormat = 6;
#[doc = "< Signed 24 bit Little Endian using low three bytes in 32-bit word"]
pub const SoundIoFormat_SoundIoFormatS24LE: SoundIoFormat = 7;
#[doc = "< Signed 24 bit Big Endian using low three bytes in 32-bit word"]
pub const SoundIoFormat_SoundIoFormatS24BE: SoundIoFormat = 8;
#[doc = "< Unsigned 24 bit Little Endian using low three bytes in 32-bit word"]
pub const SoundIoFormat_SoundIoFormatU24LE: SoundIoFormat = 9;
#[doc = "< Unsigned 24 bit Big Endian using low three bytes in 32-bit word"]
pub const SoundIoFormat_SoundIoFormatU24BE: SoundIoFormat = 10;
#[doc = "< Signed 32 bit Little Endian"]
pub const SoundIoFormat_SoundIoFormatS32LE: SoundIoFormat = 11;
#[doc = "< Signed 32 bit Big Endian"]
pub const SoundIoFormat_SoundIoFormatS32BE: SoundIoFormat = 12;
#[doc = "< Unsigned 32 bit Little Endian"]
pub const SoundIoFormat_SoundIoFormatU32LE: SoundIoFormat = 13;
#[doc = "< Unsigned 32 bit Big Endian"]
pub const SoundIoFormat_SoundIoFormatU32BE: SoundIoFormat = 14;
#[doc = "< Float 32 bit Little Endian, Range -1.0 to 1.0"]
pub const SoundIoFormat_SoundIoFormatFloat32LE: SoundIoFormat = 15;
#[doc = "< Float 32 bit Big Endian, Range -1.0 to 1.0"]
pub const SoundIoFormat_SoundIoFormatFloat32BE: SoundIoFormat = 16;
#[doc = "< Float 64 bit Little Endian, Range -1.0 to 1.0"]
pub const SoundIoFormat_SoundIoFormatFloat64LE: SoundIoFormat = 17;
#[doc = "< Float 64 bit Big Endian, Range -1.0 to 1.0"]
pub const SoundIoFormat_SoundIoFormatFloat64BE: SoundIoFormat = 18;
#[doc = " For your convenience, Native Endian and Foreign Endian constants are defined"]
#[doc = " which point to the respective SoundIoFormat values."]
pub type SoundIoFormat = ::std::os::raw::c_uint;
#[doc = " The size of this struct is OK to use."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoundIoChannelLayout {
    pub name: *const ::std::os::raw::c_char,
    pub channel_count: ::std::os::raw::c_int,
    pub channels: [SoundIoChannelId; 24usize],
}
#[test]
fn bindgen_test_layout_SoundIoChannelLayout() {
    assert_eq!(
        ::std::mem::size_of::<SoundIoChannelLayout>(),
        112usize,
        concat!("Size of: ", stringify!(SoundIoChannelLayout))
    );
    assert_eq!(
        ::std::mem::align_of::<SoundIoChannelLayout>(),
        8usize,
        concat!("Alignment of ", stringify!(SoundIoChannelLayout))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoChannelLayout>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoChannelLayout),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SoundIoChannelLayout>())).channel_count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoChannelLayout),
            "::",
            stringify!(channel_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoChannelLayout>())).channels as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoChannelLayout),
            "::",
            stringify!(channels)
        )
    );
}
#[doc = " The size of this struct is OK to use."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoundIoSampleRateRange {
    pub min: ::std::os::raw::c_int,
    pub max: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SoundIoSampleRateRange() {
    assert_eq!(
        ::std::mem::size_of::<SoundIoSampleRateRange>(),
        8usize,
        concat!("Size of: ", stringify!(SoundIoSampleRateRange))
    );
    assert_eq!(
        ::std::mem::align_of::<SoundIoSampleRateRange>(),
        4usize,
        concat!("Alignment of ", stringify!(SoundIoSampleRateRange))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoSampleRateRange>())).min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoSampleRateRange),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoSampleRateRange>())).max as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoSampleRateRange),
            "::",
            stringify!(max)
        )
    );
}
#[doc = " The size of this struct is OK to use."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoundIoChannelArea {
    #[doc = " Base address of buffer."]
    pub ptr: *mut ::std::os::raw::c_char,
    #[doc = " How many bytes it takes to get from the beginning of one sample to"]
    #[doc = " the beginning of the next sample."]
    pub step: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SoundIoChannelArea() {
    assert_eq!(
        ::std::mem::size_of::<SoundIoChannelArea>(),
        16usize,
        concat!("Size of: ", stringify!(SoundIoChannelArea))
    );
    assert_eq!(
        ::std::mem::align_of::<SoundIoChannelArea>(),
        8usize,
        concat!("Alignment of ", stringify!(SoundIoChannelArea))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoChannelArea>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoChannelArea),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoChannelArea>())).step as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoChannelArea),
            "::",
            stringify!(step)
        )
    );
}
#[doc = " The size of this struct is not part of the API or ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoundIo {
    #[doc = " Optional. Put whatever you want here. Defaults to NULL."]
    pub userdata: *mut ::std::os::raw::c_void,
    #[doc = " Optional callback. Called when the list of devices change. Only called"]
    #[doc = " during a call to ::soundio_flush_events or ::soundio_wait_events."]
    pub on_devices_change: ::std::option::Option<unsafe extern "C" fn(arg1: *mut SoundIo)>,
    #[doc = " Optional callback. Called when the backend disconnects. For example,"]
    #[doc = " when the JACK server shuts down. When this happens, listing devices"]
    #[doc = " and opening streams will always fail with"]
    #[doc = " SoundIoErrorBackendDisconnected. This callback is only called during a"]
    #[doc = " call to ::soundio_flush_events or ::soundio_wait_events."]
    #[doc = " If you do not supply a callback, the default will crash your program"]
    #[doc = " with an error message. This callback is also called when the thread"]
    #[doc = " that retrieves device information runs into an unrecoverable condition"]
    #[doc = " such as running out of memory."]
    #[doc = ""]
    #[doc = " Possible errors:"]
    #[doc = " * #SoundIoErrorBackendDisconnected"]
    #[doc = " * #SoundIoErrorNoMem"]
    #[doc = " * #SoundIoErrorSystemResources"]
    #[doc = " * #SoundIoErrorOpeningDevice - unexpected problem accessing device"]
    #[doc = "   information"]
    pub on_backend_disconnect:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut SoundIo, err: ::std::os::raw::c_int)>,
    #[doc = " Optional callback. Called from an unknown thread that you should not use"]
    #[doc = " to call any soundio functions. You may use this to signal a condition"]
    #[doc = " variable to wake up. Called when ::soundio_wait_events would be woken up."]
    pub on_events_signal: ::std::option::Option<unsafe extern "C" fn(arg1: *mut SoundIo)>,
    #[doc = " Read-only. After calling ::soundio_connect or ::soundio_connect_backend,"]
    #[doc = " this field tells which backend is currently connected."]
    pub current_backend: SoundIoBackend,
    #[doc = " Optional: Application name."]
    #[doc = " PulseAudio uses this for \"application name\"."]
    #[doc = " JACK uses this for `client_name`."]
    #[doc = " Must not contain a colon (\":\")."]
    pub app_name: *const ::std::os::raw::c_char,
    #[doc = " Optional: Real time priority warning."]
    #[doc = " This callback is fired when making thread real-time priority failed. By"]
    #[doc = " default, it will print to stderr only the first time it is called"]
    #[doc = " a message instructing the user how to configure their system to allow"]
    #[doc = " real-time priority threads. This must be set to a function not NULL."]
    #[doc = " To silence the warning, assign this to a function that does nothing."]
    pub emit_rtprio_warning: ::std::option::Option<unsafe extern "C" fn()>,
    #[doc = " Optional: JACK info callback."]
    #[doc = " By default, libsoundio sets this to an empty function in order to"]
    #[doc = " silence stdio messages from JACK. You may override the behavior by"]
    #[doc = " setting this to `NULL` or providing your own function. This is"]
    #[doc = " registered with JACK regardless of whether ::soundio_connect_backend"]
    #[doc = " succeeds."]
    pub jack_info_callback:
        ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>,
    #[doc = " Optional: JACK error callback."]
    #[doc = " See SoundIo::jack_info_callback"]
    pub jack_error_callback:
        ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>,
}
#[test]
fn bindgen_test_layout_SoundIo() {
    assert_eq!(
        ::std::mem::size_of::<SoundIo>(),
        72usize,
        concat!("Size of: ", stringify!(SoundIo))
    );
    assert_eq!(
        ::std::mem::align_of::<SoundIo>(),
        8usize,
        concat!("Alignment of ", stringify!(SoundIo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIo>())).userdata as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIo),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIo>())).on_devices_change as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIo),
            "::",
            stringify!(on_devices_change)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIo>())).on_backend_disconnect as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIo),
            "::",
            stringify!(on_backend_disconnect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIo>())).on_events_signal as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIo),
            "::",
            stringify!(on_events_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIo>())).current_backend as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIo),
            "::",
            stringify!(current_backend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIo>())).app_name as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIo),
            "::",
            stringify!(app_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIo>())).emit_rtprio_warning as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIo),
            "::",
            stringify!(emit_rtprio_warning)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIo>())).jack_info_callback as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIo),
            "::",
            stringify!(jack_info_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIo>())).jack_error_callback as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIo),
            "::",
            stringify!(jack_error_callback)
        )
    );
}
#[doc = " The size of this struct is not part of the API or ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoundIoDevice {
    #[doc = " Read-only. Set automatically."]
    pub soundio: *mut SoundIo,
    #[doc = " A string of bytes that uniquely identifies this device."]
    #[doc = " If the same physical device supports both input and output, that makes"]
    #[doc = " one SoundIoDevice for the input and one SoundIoDevice for the output."]
    #[doc = " In this case, the id of each SoundIoDevice will be the same, and"]
    #[doc = " SoundIoDevice::aim will be different. Additionally, if the device"]
    #[doc = " supports raw mode, there may be up to four devices with the same id:"]
    #[doc = " one for each value of SoundIoDevice::is_raw and one for each value of"]
    #[doc = " SoundIoDevice::aim."]
    pub id: *mut ::std::os::raw::c_char,
    #[doc = " User-friendly UTF-8 encoded text to describe the device."]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " Tells whether this device is an input device or an output device."]
    pub aim: SoundIoDeviceAim,
    #[doc = " Channel layouts are handled similarly to SoundIoDevice::formats."]
    #[doc = " If this information is missing due to a SoundIoDevice::probe_error,"]
    #[doc = " layouts will be NULL. It's OK to modify this data, for example calling"]
    #[doc = " ::soundio_sort_channel_layouts on it."]
    #[doc = " Devices are guaranteed to have at least 1 channel layout."]
    pub layouts: *mut SoundIoChannelLayout,
    pub layout_count: ::std::os::raw::c_int,
    #[doc = " See SoundIoDevice::current_format"]
    pub current_layout: SoundIoChannelLayout,
    #[doc = " List of formats this device supports. See also"]
    #[doc = " SoundIoDevice::current_format."]
    pub formats: *mut SoundIoFormat,
    #[doc = " How many formats are available in SoundIoDevice::formats."]
    pub format_count: ::std::os::raw::c_int,
    #[doc = " A device is either a raw device or it is a virtual device that is"]
    #[doc = " provided by a software mixing service such as dmix or PulseAudio (see"]
    #[doc = " SoundIoDevice::is_raw). If it is a raw device,"]
    #[doc = " current_format is meaningless;"]
    #[doc = " the device has no current format until you open it. On the other hand,"]
    #[doc = " if it is a virtual device, current_format describes the"]
    #[doc = " destination sample format that your audio will be converted to. Or,"]
    #[doc = " if you're the lucky first application to open the device, you might"]
    #[doc = " cause the current_format to change to your format."]
    #[doc = " Generally, you want to ignore current_format and use"]
    #[doc = " whatever format is most convenient"]
    #[doc = " for you which is supported by the device, because when you are the only"]
    #[doc = " application left, the mixer might decide to switch"]
    #[doc = " current_format to yours. You can learn the supported formats via"]
    #[doc = " formats and SoundIoDevice::format_count. If this information is missing"]
    #[doc = " due to a probe error, formats will be `NULL`. If current_format is"]
    #[doc = " unavailable, it will be set to #SoundIoFormatInvalid."]
    #[doc = " Devices are guaranteed to have at least 1 format available."]
    pub current_format: SoundIoFormat,
    #[doc = " Sample rate is the number of frames per second."]
    #[doc = " Sample rate is handled very similar to SoundIoDevice::formats."]
    #[doc = " If sample rate information is missing due to a probe error, the field"]
    #[doc = " will be set to NULL."]
    #[doc = " Devices which have SoundIoDevice::probe_error set to #SoundIoErrorNone are"]
    #[doc = " guaranteed to have at least 1 sample rate available."]
    pub sample_rates: *mut SoundIoSampleRateRange,
    #[doc = " How many sample rate ranges are available in"]
    #[doc = " SoundIoDevice::sample_rates. 0 if sample rate information is missing"]
    #[doc = " due to a probe error."]
    pub sample_rate_count: ::std::os::raw::c_int,
    #[doc = " See SoundIoDevice::current_format"]
    #[doc = " 0 if sample rate information is missing due to a probe error."]
    pub sample_rate_current: ::std::os::raw::c_int,
    #[doc = " Software latency minimum in seconds. If this value is unknown or"]
    #[doc = " irrelevant, it is set to 0.0."]
    #[doc = " For PulseAudio and WASAPI this value is unknown until you open a"]
    #[doc = " stream."]
    pub software_latency_min: f64,
    #[doc = " Software latency maximum in seconds. If this value is unknown or"]
    #[doc = " irrelevant, it is set to 0.0."]
    #[doc = " For PulseAudio and WASAPI this value is unknown until you open a"]
    #[doc = " stream."]
    pub software_latency_max: f64,
    #[doc = " Software latency in seconds. If this value is unknown or"]
    #[doc = " irrelevant, it is set to 0.0."]
    #[doc = " For PulseAudio and WASAPI this value is unknown until you open a"]
    #[doc = " stream."]
    #[doc = " See SoundIoDevice::current_format"]
    pub software_latency_current: f64,
    #[doc = " Raw means that you are directly opening the hardware device and not"]
    #[doc = " going through a proxy such as dmix, PulseAudio, or JACK. When you open a"]
    #[doc = " raw device, other applications on the computer are not able to"]
    #[doc = " simultaneously access the device. Raw devices do not perform automatic"]
    #[doc = " resampling and thus tend to have fewer formats available."]
    pub is_raw: bool,
    #[doc = " Devices are reference counted. See ::soundio_device_ref and"]
    #[doc = " ::soundio_device_unref."]
    pub ref_count: ::std::os::raw::c_int,
    #[doc = " This is set to a SoundIoError representing the result of the device"]
    #[doc = " probe. Ideally this will be SoundIoErrorNone in which case all the"]
    #[doc = " fields of the device will be populated. If there is an error code here"]
    #[doc = " then information about formats, sample rates, and channel layouts might"]
    #[doc = " be missing."]
    #[doc = ""]
    #[doc = " Possible errors:"]
    #[doc = " * #SoundIoErrorOpeningDevice"]
    #[doc = " * #SoundIoErrorNoMem"]
    pub probe_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SoundIoDevice() {
    assert_eq!(
        ::std::mem::size_of::<SoundIoDevice>(),
        232usize,
        concat!("Size of: ", stringify!(SoundIoDevice))
    );
    assert_eq!(
        ::std::mem::align_of::<SoundIoDevice>(),
        8usize,
        concat!("Alignment of ", stringify!(SoundIoDevice))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoDevice>())).soundio as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(soundio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoDevice>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoDevice>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoDevice>())).aim as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(aim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoDevice>())).layouts as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(layouts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoDevice>())).layout_count as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(layout_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoDevice>())).current_layout as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(current_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoDevice>())).formats as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(formats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoDevice>())).format_count as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(format_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoDevice>())).current_format as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(current_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoDevice>())).sample_rates as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(sample_rates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoDevice>())).sample_rate_count as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(sample_rate_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SoundIoDevice>())).sample_rate_current as *const _ as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(sample_rate_current)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SoundIoDevice>())).software_latency_min as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(software_latency_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SoundIoDevice>())).software_latency_max as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(software_latency_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SoundIoDevice>())).software_latency_current as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(software_latency_current)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoDevice>())).is_raw as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(is_raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoDevice>())).ref_count as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoDevice>())).probe_error as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoDevice),
            "::",
            stringify!(probe_error)
        )
    );
}
#[doc = " The size of this struct is not part of the API or ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoundIoOutStream {
    #[doc = " Populated automatically when you call ::soundio_outstream_create."]
    pub device: *mut SoundIoDevice,
    #[doc = " Defaults to #SoundIoFormatFloat32NE, followed by the first one"]
    #[doc = " supported."]
    pub format: SoundIoFormat,
    #[doc = " Sample rate is the number of frames per second."]
    #[doc = " Defaults to 48000 (and then clamped into range)."]
    pub sample_rate: ::std::os::raw::c_int,
    #[doc = " Defaults to Stereo, if available, followed by the first layout"]
    #[doc = " supported."]
    pub layout: SoundIoChannelLayout,
    #[doc = " Ignoring hardware latency, this is the number of seconds it takes for"]
    #[doc = " the last sample in a full buffer to be played."]
    #[doc = " After you call ::soundio_outstream_open, this value is replaced with the"]
    #[doc = " actual software latency, as near to this value as possible."]
    #[doc = " On systems that support clearing the buffer, this defaults to a large"]
    #[doc = " latency, potentially upwards of 2 seconds, with the understanding that"]
    #[doc = " you will call ::soundio_outstream_clear_buffer when you want to reduce"]
    #[doc = " the latency to 0. On systems that do not support clearing the buffer,"]
    #[doc = " this defaults to a reasonable lower latency value."]
    #[doc = ""]
    #[doc = " On backends with high latencies (such as 2 seconds), `frame_count_min`"]
    #[doc = " will be 0, meaning you don't have to fill the entire buffer. In this"]
    #[doc = " case, the large buffer is there if you want it; you only have to fill"]
    #[doc = " as much as you want. On backends like JACK, `frame_count_min` will be"]
    #[doc = " equal to `frame_count_max` and if you don't fill that many frames, you"]
    #[doc = " will get glitches."]
    #[doc = ""]
    #[doc = " If the device has unknown software latency min and max values, you may"]
    #[doc = " still set this, but you might not get the value you requested."]
    #[doc = " For PulseAudio, if you set this value to non-default, it sets"]
    #[doc = " `PA_STREAM_ADJUST_LATENCY` and is the value used for `maxlength` and"]
    #[doc = " `tlength`."]
    #[doc = ""]
    #[doc = " For JACK, this value is always equal to"]
    #[doc = " SoundIoDevice::software_latency_current of the device."]
    pub software_latency: f64,
    #[doc = " Core Audio and WASAPI only: current output Audio Unit volume. Float, 0.0-1.0."]
    pub volume: f32,
    #[doc = " Defaults to NULL. Put whatever you want here."]
    pub userdata: *mut ::std::os::raw::c_void,
    #[doc = " In this callback, you call ::soundio_outstream_begin_write and"]
    #[doc = " ::soundio_outstream_end_write as many times as necessary to write"]
    #[doc = " at minimum `frame_count_min` frames and at maximum `frame_count_max`"]
    #[doc = " frames. `frame_count_max` will always be greater than 0. Note that you"]
    #[doc = " should write as many frames as you can; `frame_count_min` might be 0 and"]
    #[doc = " you can still get a buffer underflow if you always write"]
    #[doc = " `frame_count_min` frames."]
    #[doc = ""]
    #[doc = " For Dummy, ALSA, and PulseAudio, `frame_count_min` will be 0. For JACK"]
    #[doc = " and CoreAudio `frame_count_min` will be equal to `frame_count_max`."]
    #[doc = ""]
    #[doc = " The code in the supplied function must be suitable for real-time"]
    #[doc = " execution. That means that it cannot call functions that might block"]
    #[doc = " for a long time. This includes all I/O functions (disk, TTY, network),"]
    #[doc = " malloc, free, printf, pthread_mutex_lock, sleep, wait, poll, select,"]
    #[doc = " pthread_join, pthread_cond_wait, etc."]
    pub write_callback: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut SoundIoOutStream,
            frame_count_min: ::std::os::raw::c_int,
            frame_count_max: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " This optional callback happens when the sound device runs out of"]
    #[doc = " buffered audio data to play. After this occurs, the outstream waits"]
    #[doc = " until the buffer is full to resume playback."]
    #[doc = " This is called from the SoundIoOutStream::write_callback thread context."]
    pub underflow_callback:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut SoundIoOutStream)>,
    #[doc = " Optional callback. `err` is always SoundIoErrorStreaming."]
    #[doc = " SoundIoErrorStreaming is an unrecoverable error. The stream is in an"]
    #[doc = " invalid state and must be destroyed."]
    #[doc = " If you do not supply error_callback, the default callback will print"]
    #[doc = " a message to stderr and then call `abort`."]
    #[doc = " This is called from the SoundIoOutStream::write_callback thread context."]
    pub error_callback: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut SoundIoOutStream, err: ::std::os::raw::c_int),
    >,
    #[doc = " Optional: Name of the stream. Defaults to \"SoundIoOutStream\""]
    #[doc = " PulseAudio uses this for the stream name."]
    #[doc = " JACK uses this for the client name of the client that connects when you"]
    #[doc = " open the stream."]
    #[doc = " WASAPI uses this for the session display name."]
    #[doc = " Must not contain a colon (\":\")."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Optional: Hint that this output stream is nonterminal. This is used by"]
    #[doc = " JACK and it means that the output stream data originates from an input"]
    #[doc = " stream. Defaults to `false`."]
    pub non_terminal_hint: bool,
    #[doc = " computed automatically when you call ::soundio_outstream_open"]
    pub bytes_per_frame: ::std::os::raw::c_int,
    #[doc = " computed automatically when you call ::soundio_outstream_open"]
    pub bytes_per_sample: ::std::os::raw::c_int,
    #[doc = " If setting the channel layout fails for some reason, this field is set"]
    #[doc = " to an error code. Possible error codes are:"]
    #[doc = " * #SoundIoErrorIncompatibleDevice"]
    pub layout_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SoundIoOutStream() {
    assert_eq!(
        ::std::mem::size_of::<SoundIoOutStream>(),
        200usize,
        concat!("Size of: ", stringify!(SoundIoOutStream))
    );
    assert_eq!(
        ::std::mem::align_of::<SoundIoOutStream>(),
        8usize,
        concat!("Alignment of ", stringify!(SoundIoOutStream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoOutStream>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoOutStream),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoOutStream>())).format as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoOutStream),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoOutStream>())).sample_rate as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoOutStream),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoOutStream>())).layout as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoOutStream),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SoundIoOutStream>())).software_latency as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoOutStream),
            "::",
            stringify!(software_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoOutStream>())).volume as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoOutStream),
            "::",
            stringify!(volume)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoOutStream>())).userdata as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoOutStream),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoOutStream>())).write_callback as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoOutStream),
            "::",
            stringify!(write_callback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SoundIoOutStream>())).underflow_callback as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoOutStream),
            "::",
            stringify!(underflow_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoOutStream>())).error_callback as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoOutStream),
            "::",
            stringify!(error_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoOutStream>())).name as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoOutStream),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SoundIoOutStream>())).non_terminal_hint as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoOutStream),
            "::",
            stringify!(non_terminal_hint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SoundIoOutStream>())).bytes_per_frame as *const _ as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoOutStream),
            "::",
            stringify!(bytes_per_frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SoundIoOutStream>())).bytes_per_sample as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoOutStream),
            "::",
            stringify!(bytes_per_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoOutStream>())).layout_error as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoOutStream),
            "::",
            stringify!(layout_error)
        )
    );
}
#[doc = " The size of this struct is not part of the API or ABI."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoundIoInStream {
    #[doc = " Populated automatically when you call ::soundio_outstream_create."]
    pub device: *mut SoundIoDevice,
    #[doc = " Defaults to #SoundIoFormatFloat32NE, followed by the first one"]
    #[doc = " supported."]
    pub format: SoundIoFormat,
    #[doc = " Sample rate is the number of frames per second."]
    #[doc = " Defaults to max(sample_rate_min, min(sample_rate_max, 48000))"]
    pub sample_rate: ::std::os::raw::c_int,
    #[doc = " Defaults to Stereo, if available, followed by the first layout"]
    #[doc = " supported."]
    pub layout: SoundIoChannelLayout,
    #[doc = " Ignoring hardware latency, this is the number of seconds it takes for a"]
    #[doc = " captured sample to become available for reading."]
    #[doc = " After you call ::soundio_instream_open, this value is replaced with the"]
    #[doc = " actual software latency, as near to this value as possible."]
    #[doc = " A higher value means less CPU usage. Defaults to a large value,"]
    #[doc = " potentially upwards of 2 seconds."]
    #[doc = " If the device has unknown software latency min and max values, you may"]
    #[doc = " still set this, but you might not get the value you requested."]
    #[doc = " For PulseAudio, if you set this value to non-default, it sets"]
    #[doc = " `PA_STREAM_ADJUST_LATENCY` and is the value used for `fragsize`."]
    #[doc = " For JACK, this value is always equal to"]
    #[doc = " SoundIoDevice::software_latency_current"]
    pub software_latency: f64,
    #[doc = " Defaults to NULL. Put whatever you want here."]
    pub userdata: *mut ::std::os::raw::c_void,
    #[doc = " In this function call ::soundio_instream_begin_read and"]
    #[doc = " ::soundio_instream_end_read as many times as necessary to read at"]
    #[doc = " minimum `frame_count_min` frames and at maximum `frame_count_max`"]
    #[doc = " frames. If you return from read_callback without having read"]
    #[doc = " `frame_count_min`, the frames will be dropped. `frame_count_max` is how"]
    #[doc = " many frames are available to read."]
    #[doc = ""]
    #[doc = " The code in the supplied function must be suitable for real-time"]
    #[doc = " execution. That means that it cannot call functions that might block"]
    #[doc = " for a long time. This includes all I/O functions (disk, TTY, network),"]
    #[doc = " malloc, free, printf, pthread_mutex_lock, sleep, wait, poll, select,"]
    #[doc = " pthread_join, pthread_cond_wait, etc."]
    pub read_callback: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut SoundIoInStream,
            frame_count_min: ::std::os::raw::c_int,
            frame_count_max: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " This optional callback happens when the sound device buffer is full,"]
    #[doc = " yet there is more captured audio to put in it."]
    #[doc = " This is never fired for PulseAudio."]
    #[doc = " This is called from the SoundIoInStream::read_callback thread context."]
    pub overflow_callback: ::std::option::Option<unsafe extern "C" fn(arg1: *mut SoundIoInStream)>,
    #[doc = " Optional callback. `err` is always SoundIoErrorStreaming."]
    #[doc = " SoundIoErrorStreaming is an unrecoverable error. The stream is in an"]
    #[doc = " invalid state and must be destroyed."]
    #[doc = " If you do not supply `error_callback`, the default callback will print"]
    #[doc = " a message to stderr and then abort()."]
    #[doc = " This is called from the SoundIoInStream::read_callback thread context."]
    pub error_callback: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut SoundIoInStream, err: ::std::os::raw::c_int),
    >,
    #[doc = " Optional: Name of the stream. Defaults to \"SoundIoInStream\";"]
    #[doc = " PulseAudio uses this for the stream name."]
    #[doc = " JACK uses this for the client name of the client that connects when you"]
    #[doc = " open the stream."]
    #[doc = " WASAPI uses this for the session display name."]
    #[doc = " Must not contain a colon (\":\")."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Optional: Hint that this input stream is nonterminal. This is used by"]
    #[doc = " JACK and it means that the data received by the stream will be"]
    #[doc = " passed on or made available to another stream. Defaults to `false`."]
    pub non_terminal_hint: bool,
    #[doc = " computed automatically when you call ::soundio_instream_open"]
    pub bytes_per_frame: ::std::os::raw::c_int,
    #[doc = " computed automatically when you call ::soundio_instream_open"]
    pub bytes_per_sample: ::std::os::raw::c_int,
    #[doc = " If setting the channel layout fails for some reason, this field is set"]
    #[doc = " to an error code. Possible error codes are: #SoundIoErrorIncompatibleDevice"]
    pub layout_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SoundIoInStream() {
    assert_eq!(
        ::std::mem::size_of::<SoundIoInStream>(),
        192usize,
        concat!("Size of: ", stringify!(SoundIoInStream))
    );
    assert_eq!(
        ::std::mem::align_of::<SoundIoInStream>(),
        8usize,
        concat!("Alignment of ", stringify!(SoundIoInStream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoInStream>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoInStream),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoInStream>())).format as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoInStream),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoInStream>())).sample_rate as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoInStream),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoInStream>())).layout as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoInStream),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SoundIoInStream>())).software_latency as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoInStream),
            "::",
            stringify!(software_latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoInStream>())).userdata as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoInStream),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoInStream>())).read_callback as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoInStream),
            "::",
            stringify!(read_callback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SoundIoInStream>())).overflow_callback as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoInStream),
            "::",
            stringify!(overflow_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoInStream>())).error_callback as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoInStream),
            "::",
            stringify!(error_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoInStream>())).name as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoInStream),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SoundIoInStream>())).non_terminal_hint as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoInStream),
            "::",
            stringify!(non_terminal_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoInStream>())).bytes_per_frame as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoInStream),
            "::",
            stringify!(bytes_per_frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SoundIoInStream>())).bytes_per_sample as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoInStream),
            "::",
            stringify!(bytes_per_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SoundIoInStream>())).layout_error as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(SoundIoInStream),
            "::",
            stringify!(layout_error)
        )
    );
}
extern "C" {
    #[doc = " See also ::soundio_version_major, ::soundio_version_minor, ::soundio_version_patch"]
    pub fn soundio_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " See also ::soundio_version_string, ::soundio_version_minor, ::soundio_version_patch"]
    pub fn soundio_version_major() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " See also ::soundio_version_major, ::soundio_version_string, ::soundio_version_patch"]
    pub fn soundio_version_minor() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " See also ::soundio_version_major, ::soundio_version_minor, ::soundio_version_string"]
    pub fn soundio_version_patch() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a SoundIo context. You may create multiple instances of this to"]
    #[doc = " connect to multiple backends. Sets all fields to defaults."]
    #[doc = " Returns `NULL` if and only if memory could not be allocated."]
    #[doc = " See also ::soundio_destroy"]
    pub fn soundio_create() -> *mut SoundIo;
}
extern "C" {
    pub fn soundio_destroy(soundio: *mut SoundIo);
}
extern "C" {
    #[doc = " Tries ::soundio_connect_backend on all available backends in order."]
    #[doc = " Possible errors:"]
    #[doc = " * #SoundIoErrorInvalid - already connected"]
    #[doc = " * #SoundIoErrorNoMem"]
    #[doc = " * #SoundIoErrorSystemResources"]
    #[doc = " * #SoundIoErrorNoSuchClient - when JACK returns `JackNoSuchClient`"]
    #[doc = " See also ::soundio_disconnect"]
    pub fn soundio_connect(soundio: *mut SoundIo) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Instead of calling ::soundio_connect you may call this function to try a"]
    #[doc = " specific backend."]
    #[doc = " Possible errors:"]
    #[doc = " * #SoundIoErrorInvalid - already connected or invalid backend parameter"]
    #[doc = " * #SoundIoErrorNoMem"]
    #[doc = " * #SoundIoErrorBackendUnavailable - backend was not compiled in"]
    #[doc = " * #SoundIoErrorSystemResources"]
    #[doc = " * #SoundIoErrorNoSuchClient - when JACK returns `JackNoSuchClient`"]
    #[doc = " * #SoundIoErrorInitAudioBackend - requested `backend` is not active"]
    #[doc = " * #SoundIoErrorBackendDisconnected - backend disconnected while connecting"]
    #[doc = " See also ::soundio_disconnect"]
    pub fn soundio_connect_backend(
        soundio: *mut SoundIo,
        backend: SoundIoBackend,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn soundio_disconnect(soundio: *mut SoundIo);
}
extern "C" {
    #[doc = " Get a string representation of a #SoundIoError"]
    pub fn soundio_strerror(error: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get a string representation of a #SoundIoBackend"]
    pub fn soundio_backend_name(backend: SoundIoBackend) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the number of available backends."]
    pub fn soundio_backend_count(soundio: *mut SoundIo) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get the available backend at the specified index"]
    #[doc = " (0 <= index < ::soundio_backend_count)"]
    pub fn soundio_get_backend(
        soundio: *mut SoundIo,
        index: ::std::os::raw::c_int,
    ) -> SoundIoBackend;
}
extern "C" {
    #[doc = " Returns whether libsoundio was compiled with backend."]
    pub fn soundio_have_backend(backend: SoundIoBackend) -> bool;
}
extern "C" {
    #[doc = " Atomically update information for all connected devices. Note that calling"]
    #[doc = " this function merely flips a pointer; the actual work of collecting device"]
    #[doc = " information is done elsewhere. It is performant to call this function many"]
    #[doc = " times per second."]
    #[doc = ""]
    #[doc = " When you call this, the following callbacks might be called:"]
    #[doc = " * SoundIo::on_devices_change"]
    #[doc = " * SoundIo::on_backend_disconnect"]
    #[doc = " This is the only time those callbacks can be called."]
    #[doc = ""]
    #[doc = " This must be called from the same thread as the thread in which you call"]
    #[doc = " these functions:"]
    #[doc = " * ::soundio_input_device_count"]
    #[doc = " * ::soundio_output_device_count"]
    #[doc = " * ::soundio_get_input_device"]
    #[doc = " * ::soundio_get_output_device"]
    #[doc = " * ::soundio_default_input_device_index"]
    #[doc = " * ::soundio_default_output_device_index"]
    #[doc = ""]
    #[doc = " Note that if you do not care about learning about updated devices, you"]
    #[doc = " might call this function only once ever and never call"]
    #[doc = " ::soundio_wait_events."]
    pub fn soundio_flush_events(soundio: *mut SoundIo);
}
extern "C" {
    #[doc = " This function calls ::soundio_flush_events then blocks until another event"]
    #[doc = " is ready or you call ::soundio_wakeup. Be ready for spurious wakeups."]
    pub fn soundio_wait_events(soundio: *mut SoundIo);
}
extern "C" {
    #[doc = " Makes ::soundio_wait_events stop blocking."]
    pub fn soundio_wakeup(soundio: *mut SoundIo);
}
extern "C" {
    #[doc = " If necessary you can manually trigger a device rescan. Normally you will"]
    #[doc = " not ever have to call this function, as libsoundio listens to system events"]
    #[doc = " for device changes and responds to them by rescanning devices and preparing"]
    #[doc = " the new device information for you to be atomically replaced when you call"]
    #[doc = " ::soundio_flush_events. However you might run into cases where you want to"]
    #[doc = " force trigger a device rescan, for example if an ALSA device has a"]
    #[doc = " SoundIoDevice::probe_error."]
    #[doc = ""]
    #[doc = " After you call this you still have to use ::soundio_flush_events or"]
    #[doc = " ::soundio_wait_events and then wait for the"]
    #[doc = " SoundIo::on_devices_change callback."]
    #[doc = ""]
    #[doc = " This can be called from any thread context except for"]
    #[doc = " SoundIoOutStream::write_callback and SoundIoInStream::read_callback"]
    pub fn soundio_force_device_scan(soundio: *mut SoundIo);
}
extern "C" {
    #[doc = " Returns whether the channel count field and each channel id matches in"]
    #[doc = " the supplied channel layouts."]
    pub fn soundio_channel_layout_equal(
        a: *const SoundIoChannelLayout,
        b: *const SoundIoChannelLayout,
    ) -> bool;
}
extern "C" {
    pub fn soundio_get_channel_name(id: SoundIoChannelId) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Given UTF-8 encoded text which is the name of a channel such as"]
    #[doc = " \"Front Left\", \"FL\", or \"front-left\", return the corresponding"]
    #[doc = " SoundIoChannelId. Returns SoundIoChannelIdInvalid for no match."]
    pub fn soundio_parse_channel_id(
        str_: *const ::std::os::raw::c_char,
        str_len: ::std::os::raw::c_int,
    ) -> SoundIoChannelId;
}
extern "C" {
    #[doc = " Returns the number of builtin channel layouts."]
    pub fn soundio_channel_layout_builtin_count() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns a builtin channel layout. 0 <= `index` < ::soundio_channel_layout_builtin_count"]
    #[doc = ""]
    #[doc = " Although `index` is of type `int`, it should be a valid"]
    #[doc = " #SoundIoChannelLayoutId enum value."]
    pub fn soundio_channel_layout_get_builtin(
        index: ::std::os::raw::c_int,
    ) -> *const SoundIoChannelLayout;
}
extern "C" {
    #[doc = " Get the default builtin channel layout for the given number of channels."]
    pub fn soundio_channel_layout_get_default(
        channel_count: ::std::os::raw::c_int,
    ) -> *const SoundIoChannelLayout;
}
extern "C" {
    #[doc = " Return the index of `channel` in `layout`, or `-1` if not found."]
    pub fn soundio_channel_layout_find_channel(
        layout: *const SoundIoChannelLayout,
        channel: SoundIoChannelId,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Populates the name field of layout if it matches a builtin one."]
    #[doc = " returns whether it found a match"]
    pub fn soundio_channel_layout_detect_builtin(layout: *mut SoundIoChannelLayout) -> bool;
}
extern "C" {
    #[doc = " Iterates over preferred_layouts. Returns the first channel layout in"]
    #[doc = " preferred_layouts which matches one of the channel layouts in"]
    #[doc = " available_layouts. Returns NULL if none matches."]
    pub fn soundio_best_matching_channel_layout(
        preferred_layouts: *const SoundIoChannelLayout,
        preferred_layout_count: ::std::os::raw::c_int,
        available_layouts: *const SoundIoChannelLayout,
        available_layout_count: ::std::os::raw::c_int,
    ) -> *const SoundIoChannelLayout;
}
extern "C" {
    #[doc = " Sorts by channel count, descending."]
    pub fn soundio_sort_channel_layouts(
        layouts: *mut SoundIoChannelLayout,
        layout_count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Returns -1 on invalid format."]
    pub fn soundio_get_bytes_per_sample(format: SoundIoFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns string representation of `format`."]
    pub fn soundio_format_string(format: SoundIoFormat) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the number of input devices."]
    #[doc = " Returns -1 if you never called ::soundio_flush_events."]
    pub fn soundio_input_device_count(soundio: *mut SoundIo) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of output devices."]
    #[doc = " Returns -1 if you never called ::soundio_flush_events."]
    pub fn soundio_output_device_count(soundio: *mut SoundIo) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Always returns a device. Call ::soundio_device_unref when done."]
    #[doc = " `index` must be 0 <= index < ::soundio_input_device_count"]
    #[doc = " Returns NULL if you never called ::soundio_flush_events or if you provide"]
    #[doc = " invalid parameter values."]
    pub fn soundio_get_input_device(
        soundio: *mut SoundIo,
        index: ::std::os::raw::c_int,
    ) -> *mut SoundIoDevice;
}
extern "C" {
    #[doc = " Always returns a device. Call ::soundio_device_unref when done."]
    #[doc = " `index` must be 0 <= index < ::soundio_output_device_count"]
    #[doc = " Returns NULL if you never called ::soundio_flush_events or if you provide"]
    #[doc = " invalid parameter values."]
    pub fn soundio_get_output_device(
        soundio: *mut SoundIo,
        index: ::std::os::raw::c_int,
    ) -> *mut SoundIoDevice;
}
extern "C" {
    #[doc = " returns the index of the default input device"]
    #[doc = " returns -1 if there are no devices or if you never called"]
    #[doc = " ::soundio_flush_events."]
    pub fn soundio_default_input_device_index(soundio: *mut SoundIo) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns the index of the default output device"]
    #[doc = " returns -1 if there are no devices or if you never called"]
    #[doc = " ::soundio_flush_events."]
    pub fn soundio_default_output_device_index(soundio: *mut SoundIo) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add 1 to the reference count of `device`."]
    pub fn soundio_device_ref(device: *mut SoundIoDevice);
}
extern "C" {
    #[doc = " Remove 1 to the reference count of `device`. Clean up if it was the last"]
    #[doc = " reference."]
    pub fn soundio_device_unref(device: *mut SoundIoDevice);
}
extern "C" {
    #[doc = " Return `true` if and only if the devices have the same SoundIoDevice::id,"]
    #[doc = " SoundIoDevice::is_raw, and SoundIoDevice::aim are the same."]
    pub fn soundio_device_equal(a: *const SoundIoDevice, b: *const SoundIoDevice) -> bool;
}
extern "C" {
    #[doc = " Sorts channel layouts by channel count, descending."]
    pub fn soundio_device_sort_channel_layouts(device: *mut SoundIoDevice);
}
extern "C" {
    #[doc = " Convenience function. Returns whether `format` is included in the device's"]
    #[doc = " supported formats."]
    pub fn soundio_device_supports_format(
        device: *mut SoundIoDevice,
        format: SoundIoFormat,
    ) -> bool;
}
extern "C" {
    #[doc = " Convenience function. Returns whether `layout` is included in the device's"]
    #[doc = " supported channel layouts."]
    pub fn soundio_device_supports_layout(
        device: *mut SoundIoDevice,
        layout: *const SoundIoChannelLayout,
    ) -> bool;
}
extern "C" {
    #[doc = " Convenience function. Returns whether `sample_rate` is included in the"]
    #[doc = " device's supported sample rates."]
    pub fn soundio_device_supports_sample_rate(
        device: *mut SoundIoDevice,
        sample_rate: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Convenience function. Returns the available sample rate nearest to"]
    #[doc = " `sample_rate`, rounding up."]
    pub fn soundio_device_nearest_sample_rate(
        device: *mut SoundIoDevice,
        sample_rate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocates memory and sets defaults. Next you should fill out the struct fields"]
    #[doc = " and then call ::soundio_outstream_open. Sets all fields to defaults."]
    #[doc = " Returns `NULL` if and only if memory could not be allocated."]
    #[doc = " See also ::soundio_outstream_destroy"]
    pub fn soundio_outstream_create(device: *mut SoundIoDevice) -> *mut SoundIoOutStream;
}
extern "C" {
    #[doc = " You may not call this function from the SoundIoOutStream::write_callback thread context."]
    pub fn soundio_outstream_destroy(outstream: *mut SoundIoOutStream);
}
extern "C" {
    #[doc = " After you call this function, SoundIoOutStream::software_latency is set to"]
    #[doc = " the correct value."]
    #[doc = ""]
    #[doc = " The next thing to do is call ::soundio_outstream_start."]
    #[doc = " If this function returns an error, the outstream is in an invalid state and"]
    #[doc = " you must call ::soundio_outstream_destroy on it."]
    #[doc = ""]
    #[doc = " Possible errors:"]
    #[doc = " * #SoundIoErrorInvalid"]
    #[doc = "   * SoundIoDevice::aim is not #SoundIoDeviceAimOutput"]
    #[doc = "   * SoundIoOutStream::format is not valid"]
    #[doc = "   * SoundIoOutStream::channel_count is greater than #SOUNDIO_MAX_CHANNELS"]
    #[doc = " * #SoundIoErrorNoMem"]
    #[doc = " * #SoundIoErrorOpeningDevice"]
    #[doc = " * #SoundIoErrorBackendDisconnected"]
    #[doc = " * #SoundIoErrorSystemResources"]
    #[doc = " * #SoundIoErrorNoSuchClient - when JACK returns `JackNoSuchClient`"]
    #[doc = " * #SoundIoErrorIncompatibleBackend - SoundIoOutStream::channel_count is"]
    #[doc = "   greater than the number of channels the backend can handle."]
    #[doc = " * #SoundIoErrorIncompatibleDevice - stream parameters requested are not"]
    #[doc = "   compatible with the chosen device."]
    pub fn soundio_outstream_open(outstream: *mut SoundIoOutStream) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " After you call this function, SoundIoOutStream::write_callback will be called."]
    #[doc = ""]
    #[doc = " This function might directly call SoundIoOutStream::write_callback."]
    #[doc = ""]
    #[doc = " Possible errors:"]
    #[doc = " * #SoundIoErrorStreaming"]
    #[doc = " * #SoundIoErrorNoMem"]
    #[doc = " * #SoundIoErrorSystemResources"]
    #[doc = " * #SoundIoErrorBackendDisconnected"]
    pub fn soundio_outstream_start(outstream: *mut SoundIoOutStream) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call this function when you are ready to begin writing to the device buffer."]
    #[doc = "  * `outstream` - (in) The output stream you want to write to."]
    #[doc = "  * `areas` - (out) The memory addresses you can write data to, one per"]
    #[doc = "    channel. It is OK to modify the pointers if that helps you iterate."]
    #[doc = "  * `frame_count` - (in/out) Provide the number of frames you want to write."]
    #[doc = "    Returned will be the number of frames you can actually write, which is"]
    #[doc = "    also the number of frames that will be written when you call"]
    #[doc = "    ::soundio_outstream_end_write. The value returned will always be less"]
    #[doc = "    than or equal to the value provided."]
    #[doc = " It is your responsibility to call this function exactly as many times as"]
    #[doc = " necessary to meet the `frame_count_min` and `frame_count_max` criteria from"]
    #[doc = " SoundIoOutStream::write_callback."]
    #[doc = " You must call this function only from the SoundIoOutStream::write_callback thread context."]
    #[doc = " After calling this function, write data to `areas` and then call"]
    #[doc = " ::soundio_outstream_end_write."]
    #[doc = " If this function returns an error, do not call ::soundio_outstream_end_write."]
    #[doc = ""]
    #[doc = " Possible errors:"]
    #[doc = " * #SoundIoErrorInvalid"]
    #[doc = "   * `*frame_count` <= 0"]
    #[doc = "   * `*frame_count` < `frame_count_min` or `*frame_count` > `frame_count_max`"]
    #[doc = "   * function called too many times without respecting `frame_count_max`"]
    #[doc = " * #SoundIoErrorStreaming"]
    #[doc = " * #SoundIoErrorUnderflow - an underflow caused this call to fail. You might"]
    #[doc = "   also get a SoundIoOutStream::underflow_callback, and you might not get"]
    #[doc = "   this error code when an underflow occurs. Unlike #SoundIoErrorStreaming,"]
    #[doc = "   the outstream is still in a valid state and streaming can continue."]
    #[doc = " * #SoundIoErrorIncompatibleDevice - in rare cases it might just now"]
    #[doc = "   be discovered that the device uses non-byte-aligned access, in which"]
    #[doc = "   case this error code is returned."]
    pub fn soundio_outstream_begin_write(
        outstream: *mut SoundIoOutStream,
        areas: *mut *mut SoundIoChannelArea,
        frame_count: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Commits the write that you began with ::soundio_outstream_begin_write."]
    #[doc = " You must call this function only from the SoundIoOutStream::write_callback thread context."]
    #[doc = ""]
    #[doc = " Possible errors:"]
    #[doc = " * #SoundIoErrorStreaming"]
    #[doc = " * #SoundIoErrorUnderflow - an underflow caused this call to fail. You might"]
    #[doc = "   also get a SoundIoOutStream::underflow_callback, and you might not get"]
    #[doc = "   this error code when an underflow occurs. Unlike #SoundIoErrorStreaming,"]
    #[doc = "   the outstream is still in a valid state and streaming can continue."]
    pub fn soundio_outstream_end_write(outstream: *mut SoundIoOutStream) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clears the output stream buffer."]
    #[doc = " This function can be called from any thread."]
    #[doc = " This function can be called regardless of whether the outstream is paused"]
    #[doc = " or not."]
    #[doc = " Some backends do not support clearing the buffer. On these backends this"]
    #[doc = " function will return SoundIoErrorIncompatibleBackend."]
    #[doc = " Some devices do not support clearing the buffer. On these devices this"]
    #[doc = " function might return SoundIoErrorIncompatibleDevice."]
    #[doc = " Possible errors:"]
    #[doc = ""]
    #[doc = " * #SoundIoErrorStreaming"]
    #[doc = " * #SoundIoErrorIncompatibleBackend"]
    #[doc = " * #SoundIoErrorIncompatibleDevice"]
    pub fn soundio_outstream_clear_buffer(
        outstream: *mut SoundIoOutStream,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If the underlying backend and device support pausing, this pauses the"]
    #[doc = " stream. SoundIoOutStream::write_callback may be called a few more times if"]
    #[doc = " the buffer is not full."]
    #[doc = " Pausing might put the hardware into a low power state which is ideal if your"]
    #[doc = " software is silent for some time."]
    #[doc = " This function may be called from any thread context, including"]
    #[doc = " SoundIoOutStream::write_callback."]
    #[doc = " Pausing when already paused or unpausing when already unpaused has no"]
    #[doc = " effect and returns #SoundIoErrorNone."]
    #[doc = ""]
    #[doc = " Possible errors:"]
    #[doc = " * #SoundIoErrorBackendDisconnected"]
    #[doc = " * #SoundIoErrorStreaming"]
    #[doc = " * #SoundIoErrorIncompatibleDevice - device does not support"]
    #[doc = "   pausing/unpausing. This error code might not be returned even if the"]
    #[doc = "   device does not support pausing/unpausing."]
    #[doc = " * #SoundIoErrorIncompatibleBackend - backend does not support"]
    #[doc = "   pausing/unpausing."]
    #[doc = " * #SoundIoErrorInvalid - outstream not opened and started"]
    pub fn soundio_outstream_pause(
        outstream: *mut SoundIoOutStream,
        pause: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obtain the total number of seconds that the next frame written after the"]
    #[doc = " last frame written with ::soundio_outstream_end_write will take to become"]
    #[doc = " audible. This includes both software and hardware latency. In other words,"]
    #[doc = " if you call this function directly after calling ::soundio_outstream_end_write,"]
    #[doc = " this gives you the number of seconds that the next frame written will take"]
    #[doc = " to become audible."]
    #[doc = ""]
    #[doc = " This function must be called only from within SoundIoOutStream::write_callback."]
    #[doc = ""]
    #[doc = " Possible errors:"]
    #[doc = " * #SoundIoErrorStreaming"]
    pub fn soundio_outstream_get_latency(
        outstream: *mut SoundIoOutStream,
        out_latency: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn soundio_outstream_set_volume(
        outstream: *mut SoundIoOutStream,
        volume: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocates memory and sets defaults. Next you should fill out the struct fields"]
    #[doc = " and then call ::soundio_instream_open. Sets all fields to defaults."]
    #[doc = " Returns `NULL` if and only if memory could not be allocated."]
    #[doc = " See also ::soundio_instream_destroy"]
    pub fn soundio_instream_create(device: *mut SoundIoDevice) -> *mut SoundIoInStream;
}
extern "C" {
    #[doc = " You may not call this function from SoundIoInStream::read_callback."]
    pub fn soundio_instream_destroy(instream: *mut SoundIoInStream);
}
extern "C" {
    #[doc = " After you call this function, SoundIoInStream::software_latency is set to the correct"]
    #[doc = " value."]
    #[doc = " The next thing to do is call ::soundio_instream_start."]
    #[doc = " If this function returns an error, the instream is in an invalid state and"]
    #[doc = " you must call ::soundio_instream_destroy on it."]
    #[doc = ""]
    #[doc = " Possible errors:"]
    #[doc = " * #SoundIoErrorInvalid"]
    #[doc = "   * device aim is not #SoundIoDeviceAimInput"]
    #[doc = "   * format is not valid"]
    #[doc = "   * requested layout channel count > #SOUNDIO_MAX_CHANNELS"]
    #[doc = " * #SoundIoErrorOpeningDevice"]
    #[doc = " * #SoundIoErrorNoMem"]
    #[doc = " * #SoundIoErrorBackendDisconnected"]
    #[doc = " * #SoundIoErrorSystemResources"]
    #[doc = " * #SoundIoErrorNoSuchClient"]
    #[doc = " * #SoundIoErrorIncompatibleBackend"]
    #[doc = " * #SoundIoErrorIncompatibleDevice"]
    pub fn soundio_instream_open(instream: *mut SoundIoInStream) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " After you call this function, SoundIoInStream::read_callback will be called."]
    #[doc = ""]
    #[doc = " Possible errors:"]
    #[doc = " * #SoundIoErrorBackendDisconnected"]
    #[doc = " * #SoundIoErrorStreaming"]
    #[doc = " * #SoundIoErrorOpeningDevice"]
    #[doc = " * #SoundIoErrorSystemResources"]
    pub fn soundio_instream_start(instream: *mut SoundIoInStream) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call this function when you are ready to begin reading from the device"]
    #[doc = " buffer."]
    #[doc = " * `instream` - (in) The input stream you want to read from."]
    #[doc = " * `areas` - (out) The memory addresses you can read data from. It is OK"]
    #[doc = "   to modify the pointers if that helps you iterate. There might be a \"hole\""]
    #[doc = "   in the buffer. To indicate this, `areas` will be `NULL` and `frame_count`"]
    #[doc = "   tells how big the hole is in frames."]
    #[doc = " * `frame_count` - (in/out) - Provide the number of frames you want to read;"]
    #[doc = "   returns the number of frames you can actually read. The returned value"]
    #[doc = "   will always be less than or equal to the provided value. If the provided"]
    #[doc = "   value is less than `frame_count_min` from SoundIoInStream::read_callback this function"]
    #[doc = "   returns with #SoundIoErrorInvalid."]
    #[doc = " It is your responsibility to call this function no more and no fewer than the"]
    #[doc = " correct number of times according to the `frame_count_min` and"]
    #[doc = " `frame_count_max` criteria from SoundIoInStream::read_callback."]
    #[doc = " You must call this function only from the SoundIoInStream::read_callback thread context."]
    #[doc = " After calling this function, read data from `areas` and then use"]
    #[doc = " ::soundio_instream_end_read` to actually remove the data from the buffer"]
    #[doc = " and move the read index forward. ::soundio_instream_end_read should not be"]
    #[doc = " called if the buffer is empty (`frame_count` == 0), but it should be called"]
    #[doc = " if there is a hole."]
    #[doc = ""]
    #[doc = " Possible errors:"]
    #[doc = " * #SoundIoErrorInvalid"]
    #[doc = "   * `*frame_count` < `frame_count_min` or `*frame_count` > `frame_count_max`"]
    #[doc = " * #SoundIoErrorStreaming"]
    #[doc = " * #SoundIoErrorIncompatibleDevice - in rare cases it might just now"]
    #[doc = "   be discovered that the device uses non-byte-aligned access, in which"]
    #[doc = "   case this error code is returned."]
    pub fn soundio_instream_begin_read(
        instream: *mut SoundIoInStream,
        areas: *mut *mut SoundIoChannelArea,
        frame_count: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " This will drop all of the frames from when you called"]
    #[doc = " ::soundio_instream_begin_read."]
    #[doc = " You must call this function only from the SoundIoInStream::read_callback thread context."]
    #[doc = " You must call this function only after a successful call to"]
    #[doc = " ::soundio_instream_begin_read."]
    #[doc = ""]
    #[doc = " Possible errors:"]
    #[doc = " * #SoundIoErrorStreaming"]
    pub fn soundio_instream_end_read(instream: *mut SoundIoInStream) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " If the underyling device supports pausing, this pauses the stream and"]
    #[doc = " prevents SoundIoInStream::read_callback from being called. Otherwise this returns"]
    #[doc = " #SoundIoErrorIncompatibleDevice."]
    #[doc = " This function may be called from any thread."]
    #[doc = " Pausing when already paused or unpausing when already unpaused has no"]
    #[doc = " effect and always returns #SoundIoErrorNone."]
    #[doc = ""]
    #[doc = " Possible errors:"]
    #[doc = " * #SoundIoErrorBackendDisconnected"]
    #[doc = " * #SoundIoErrorStreaming"]
    #[doc = " * #SoundIoErrorIncompatibleDevice - device does not support pausing/unpausing"]
    pub fn soundio_instream_pause(
        instream: *mut SoundIoInStream,
        pause: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obtain the number of seconds that the next frame of sound being"]
    #[doc = " captured will take to arrive in the buffer, plus the amount of time that is"]
    #[doc = " represented in the buffer. This includes both software and hardware latency."]
    #[doc = ""]
    #[doc = " This function must be called only from within SoundIoInStream::read_callback."]
    #[doc = ""]
    #[doc = " Possible errors:"]
    #[doc = " * #SoundIoErrorStreaming"]
    pub fn soundio_instream_get_latency(
        instream: *mut SoundIoInStream,
        out_latency: *mut f64,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SoundIoRingBuffer {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " A ring buffer is a single-reader single-writer lock-free fixed-size queue."]
    #[doc = " libsoundio ring buffers use memory mapping techniques to enable a"]
    #[doc = " contiguous buffer when reading or writing across the boundary of the ring"]
    #[doc = " buffer's capacity."]
    #[doc = " `requested_capacity` in bytes."]
    #[doc = " Returns `NULL` if and only if memory could not be allocated."]
    #[doc = " Use ::soundio_ring_buffer_capacity to get the actual capacity, which might"]
    #[doc = " be greater for alignment purposes."]
    #[doc = " See also ::soundio_ring_buffer_destroy"]
    pub fn soundio_ring_buffer_create(
        soundio: *mut SoundIo,
        requested_capacity: ::std::os::raw::c_int,
    ) -> *mut SoundIoRingBuffer;
}
extern "C" {
    pub fn soundio_ring_buffer_destroy(ring_buffer: *mut SoundIoRingBuffer);
}
extern "C" {
    #[doc = " When you create a ring buffer, capacity might be more than the requested"]
    #[doc = " capacity for alignment purposes. This function returns the actual capacity."]
    pub fn soundio_ring_buffer_capacity(
        ring_buffer: *mut SoundIoRingBuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Do not write more than capacity."]
    pub fn soundio_ring_buffer_write_ptr(
        ring_buffer: *mut SoundIoRingBuffer,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " `count` in bytes."]
    pub fn soundio_ring_buffer_advance_write_ptr(
        ring_buffer: *mut SoundIoRingBuffer,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Do not read more than capacity."]
    pub fn soundio_ring_buffer_read_ptr(
        ring_buffer: *mut SoundIoRingBuffer,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " `count` in bytes."]
    pub fn soundio_ring_buffer_advance_read_ptr(
        ring_buffer: *mut SoundIoRingBuffer,
        count: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Returns how many bytes of the buffer is used, ready for reading."]
    pub fn soundio_ring_buffer_fill_count(
        ring_buffer: *mut SoundIoRingBuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns how many bytes of the buffer is free, ready for writing."]
    pub fn soundio_ring_buffer_free_count(
        ring_buffer: *mut SoundIoRingBuffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Must be called by the writer."]
    pub fn soundio_ring_buffer_clear(ring_buffer: *mut SoundIoRingBuffer);
}
